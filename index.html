<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCOMP SIMULATOR</title>
    
    <style>
     body {
    margin: 0;
    height: 100vh;
    display: flex;
    background-image: url("assets/cidadefundosite.jpg");
    background-size: cover;
    backdrop-filter: blur(5px);
  }

    .novel{
        display: block;
        box-shadow: 0 0 5px .1px #181818ba;
        width: 878px;
        margin: auto;
        background-color: rgba(255, 255, 255);
        position: relative;
        min-height: 560px;
}

    .btn{
        box-sizing: inherit;
        font-family: Arvo, serif;
        background-color: rgb(91, 20, 222);
        text-shadow: 0 1px 2px rgb(50, 13, 118);
        border: none;
        border-bottom-right-radius: 9px;
        border-top-right-radius: 9px;
        background-image: linear-gradient(transparent, rgba(0, 0, 0, 0.2));
        box-shadow: -1px -1px 6.72px .28px #0006;
        padding: 11px 10px 10px 20px;
        color: #fff;
        font-size: 13px;
        font-weight: 700;
        position: absolute;
        top: 7px;
        left: -10px;
        cursor: pointer;
        transition: left 0.3s;
        pointer-events: auto;
        display: inline-block;
}

.cenario{
        width: 878px;
        margin: auto;
        background-color: rgba(255, 255, 255);
        position: absolute;
        background-size: cover;
        min-height: 560px
    }

    .caixadeescolhas{
        background-color: rgba(255, 255, 255, 0.85);
        border: 3px solid rgb(91, 20, 222); 
        box-sizing: border-box;
        color: rgb(51, 51, 51);
        line-height: 1.4;
        padding: 15px 20px;
        width: 831px;
        position: absolute;
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 30;
        display: flex;
        flex-direction: column; 
        gap: 10px; 
        margin-top: auto; 
    }

    .escolha{
        cursor: pointer;
        background: rgba(255, 255, 255, 0);
        color: rgba(104, 56, 152, 0.85) ;
        padding: 3px 10px 3px 10px;
        line-height: 24px;
        font-size: 18px;
        transition: all 0.3s;
        font-family: Arvo, serif;
    }

    .escolha:hover:not([disabled]){
        background: rgba(104, 56, 152);
        color: rgba(255, 255, 255);
    }
  
    .personagem {
        position: absolute;
        right: -85px;
        padding: 94px;
        display: flex;
        align-items: center;
        gap: 10px;
}

    .avatar{
        width: 311px;
        
    }

    .faladopersonagem{
        background-color: #ffffffd9;
        border-radius: 25px;
        border: 3px solid white;
        box-sizing: content-box;
        font-size: 17px;
        font-weight: normal;
        line-height: 30px;
        padding: 13px 16px;
        position: absolute;
        text-align: left;
        z-index: 20;
        overflow-wrap: break-word;
        top: 26.5086%;
        left: 15.7812%;
        max-width: 23.75%;
        font-family: Arvo, serif;
    }

    .obst {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #250bec;
    border-radius: 8px;
    z-index: 4;
  }

  .obst2 {
    position: absolute;
    width: 40px;
    height: 20px;
    background: #250bec;
    border-radius: 0px;
    z-index: 4;
  }

    .blocoLab {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #880afe;
    border-radius: 99px;
  }

  .arena {
    display: none;
    margin: auto;
    position: relative;
    width: 1300px;
    height: 700px;
    background: #222;
    border: 3px solid #555;
    border-radius: 12px;
    overflow: hidden;
    z-index: 2
  }

  .bloco {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #b300ff;
    border-radius: 8px;
    z-index: 4;
  }

  .broche {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #ffffff;
    border-radius: 20px;
    z-index: 2;
    }

  .gameover {
    position: absolute;
    width: 1300px;
    height: 700px;
    background: #ffd700;
    border-radius: 8px;
    z-index: 10;
  }

  .TelaInicial {
    background-image: url('assets/minigamestarscreen.jpg');
    background-size: cover;
    position: absolute;
    width: 1300px;
    height: 700px;
    border-radius: 8px;
    z-index: 10;
  }

  .inimigo {
    background-image: url('assets/bigcarlos-bravo.png');
    background-size: cover;
    position: absolute;
    width: 70px;
    height: 70px;
    border-radius: 8px;
    z-index: 4;
  }

   .brocheCobertor {
    position: absolute;
    width: 30px;
    height: 30px;
    background: #222;
    border-radius: 20px;
    z-index: 3;
    }
    </style>
</head>
<body>
    <audio id="musicaFundo" preload="auto" autoplay loop>
    <source src="assets/jazz-lounge-elevator-music-332339.mp3" type="audio/mpeg">
    </audio>
  
    <div class="arena" id="arena"></div>
    <div class="novel">
        <div class="faladopersonagem"></div>
        <div class="cenario"></div>
        <div class="personagem">
            <img class="avatar" src="" alt="avatar"><img>
        </div>
        <div class="caixadeescolhas">
            <div class="escolha"></div>
        </div>
    </div>
    <button class="btn">Início</button>
</body>
<script src="minigame/labirinto.js"></script>
<script>

//Aqui temos a lista com o objeto que representam os personagens, contendo o id deles e o url do avatar que será exibido 
//Implementamos mais dois personagens: Good Ways e Kal-el Freira! 
const personagens = {
   pinguitor: {nome: 'Pinguitor', avatar: 'assets/pinguitor.png'},
   goodways: {nome: 'Good Ways', avatar: 'assets/goodways.png'},
   kalelfreira: {nome: 'Kal-El Freira', avatar: 'assets/kal-elfeliz.png'},
   kalelfreirabravo: {nome: 'Kal-El Freira', avatar: 'assets/kal-elbravo.png'},
   bigc: {nome: 'Big C', avatar: 'assets/bigcarlos-triste.png'},
   nobody: {nome: 'nobody', avatar: 'assets/nobody.png'}
}

//Aqui criamos outra lista que contém as cenas. Elas detalham o personagem pelo id da lista anterior (puxa o avatar e o nome do personagem)
//Além disso ele determina o cenário da cena, o diálogo a ser exibido e um array com as diferentes opções.
//Colocamos novos cenários!
const cenas = {
  inicio: {
    personagem: 'pinguitor',
    cenario: 'assets/fundo_ufs.jpg',
    dialogo: 'Olá, seja bem-vindo ao DCOMP! Eu sou o Pinguitor, arauto da atlética Bugados e serei seu guia',
    opcoes: [
      {opcao: 1, texto: 'A. Vamos lá!' , proximaCena: 'escolhaderotas'}
    ]
  },

 escolhaderotas: {
    personagem: 'pinguitor',
    cenario: 'assets/fundo_ufs.jpg',
    dialogo: 'Escolha uma das rotas para conhecer mais sobre as aventuras do curso:',
    opcoes: [
      {opcao: 1, texto: 'A. Rota do Peregrino' , proximaCena: 'apresentacaogoodways'},
      {opcao: 2, texto: 'B. Rota do Arauto das Normas' , proximaCena: 'olakalelfreira'}, //tinhamos cometido um erro no nome da rota
      {opcao: 3, texto: 'C. Rota do AdCoffee' , proximaCena: 'uminimigoteespera'}//mudança no nome da rota
    ]
  },

  apresentacaogoodways: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Perdoe-me! Meu nome é Good Ways e sou professor do DCOMP, além de secretário regional da SBC!',
    opcoes: [
      {opcao: 1, texto: 'A. Prazer! Mas o que é SBC?' , proximaCena: 'explicacaosbc'}
    ]
  },

  explicacaosbc: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'A SBC é a Sociedade Brasileira de Computeiros: é ela que contribui desde a formação da grade dos cursos à eventos da área!',
    opcoes: [
      {opcao: 1, texto: 'A. Legal... Mas quando vamos começar os "Bons Caminhos"?' , proximaCena: 'comecodajornada'}
    ]
  },

  comecodajornada: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Pelo visto você sabe! Bom, já que insiste, lhe mostrarei os bons caminhos. É bem simples até.',
    opcoes: [
      {opcao: 1, texto: 'A. (Próxima Cena)' , proximaCena: 'explicacaodolabirinto'}
    ]
  },

  explicacaodolabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Consiste em um labirinto que te levará direto para o segredo de como codar melhor e se tornar um verdadeiro dcomper.',
    opcoes: [
      {opcao: 1, texto: 'A. (Próxima Cena)' , proximaCena: 'vamospraolabirinto'}
    ]
  },

vamospraolabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Não há como errar, você apenas precisa achar bons caminhos e pegar o prêmio. Está pronto?',
    opcoes: [
      {opcao: 1, texto: 'A. Com certeza!' , proximaCena: 'labirinto'}
    ]
  },

  venceulabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Dcomper, viva! Você concluiu a missão com êxito, aqui está!',
    opcoes: [
      {opcao: 1, texto: 'A. (Pegar o Pergaminho do Poderoso Dev)' , proximaCena: 'pergaminho'}
    ]
  },

   olakalelfreira: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Olá, dcomper! Me chamo Kal-el Freira e lhe ensinarei sobre o conjunto de normas que rege esta Cidade Universitária!',
    opcoes: [
      {opcao: 1, texto: 'A. É tipo etiqueta?' , proximaCena: 'aufseumaselva'}
    ]
  },

  aufseumaselva: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Não! Vamos lá: imagine que a UFS é um selva. Aqui você encontrará todo tipo de bicho: do mais pacífico até o mais feroz',
    opcoes: [
      {opcao: 1, texto: 'A. Eita, pêga! Mas o que as normas tem a ver com isso?' , proximaCena: 'kalelexplicaasnormas'}
    ]
  },

  kalelexplicaasnormas: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Elas são os artefatos que lhe protegem desses predadores e garante o sucesso em sua jornada!',
    opcoes: [
      {opcao: 1, texto: 'A. Como eu consigo as normas?' , proximaCena: 'kaleltedaumamissao'}
    ]
  },

  kaleltedaumamissao: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Sou eu quem as guardo! Mas para te dar as normas vou te fazer perguntas e se responder corretamente, você terá a chave para as normas!',
    opcoes: [
      {opcao: 1, texto: 'A. Moleza, moleza' , proximaCena: 'kaleldaumaviso'}
    ]
  },

    kaleldaumaviso: {
    personagem: 'kalelfreirabravo',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Não se engane, jovem! Você verá que esse desafio não é um mero jogo, se errar você será JUBILADO!',
    opcoes: [
      {opcao: 1, texto: 'A. Tá, vamo lá...' , proximaCena: 'kaleldaumaviso'}
    ]
  },

    uminimigoteespera: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Aqui reza a lenda de que você consegue café de graça, mas existe um inimigo poderoso. Você quer enfrentá-lo?',
    opcoes: [
      {opcao: 1, texto: 'A. Vamos nessa!' , proximaCena: 'minigame'}
    ]
  },
  
  ganhouminigame: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Você consegui, siga pela porta pra pegar sua recompensa!',
    opcoes: [
      {opcao: 1, texto: 'A. (Entrar no AdCoffee)' , proximaCena: 'pegarcafe'}
    ]
  },

  pegarcafe: {
    personagem: 'bigc',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Tenho que admitir minha derrota, aqui está jovem!',
    opcoes: [
      {opcao: 1, texto: 'A. (Pegar café)' , proximaCena: 'cafe'}
    ]
  },

  cafe: {
    personagem: 'nobody',
    cenario: 'assets/fotocafe.jpg',
    dialogo: 'Você obteve o café do AdCoffee!',
    opcoes: [
      {opcao: 1, texto: 'A. (Escolher outra rota)' , proximaCena: 'escolhaderotas'}
    ]
  },

  ganhoulabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Dcomper, viva! Você conseguiu coletar o pergaminho para codar pelos Bons Caminhos! E agora, pronto pra mais uma história?',
    opcoes: [
      {opcao: 1, texto: 'A. Com certeza!' , proximaCena: 'escolhaderotas'}
    ]
  },

  perdeuminigame: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Não foi dessa vez. O que pretende fazer?',
    opcoes: [
      {opcao: 1, texto: 'A. Revanche!' , proximaCena: 'minigame'},
      {opcao: 2, texto: 'B. Escolher outra rota' , proximaCena: 'escolhaderotas'} //erro sutil corrigido, as opções estavam com o mesmo número
    ]
  }
}


//Essa função procura no objeto "cenas" um id correspondente com a cena e retorna os elementos pedidos. 
//Optamos por usar "cenas" como um objeto ao invés de um array pela praticidade buscar o id
//sem ter que buscar pela posição, indo diretamente em busca da string do nome da cena.
const carregarCena = (idCena) => {
    const cena = cenas[idCena]
    const personagem = personagens[cena.personagem]
    return {
        avatar: personagem.avatar,
        dialogo: cena.dialogo,
        cenario: cena.cenario,
        opcoes: cena.opcoes
    }
  }

//Essa função, por sua vez, utiliza os elementos passados por carregarCena através do id da cena 
//e usa o querySelector para atualizar os elementos no DOM. Usa o reduce pra concatenar 
//as respostas como botões clicáveis, que envia o id pra passar de cena e exibe o texto da 
//escolha da cena para o jogador identificar as opções.
const renderizarCena = (cenaId) => {
    if (cenaId === 'minigame') {
      document.querySelector(".arena").style.display = "block"
      document.querySelector(".novel").style.display = "none"
      StartMinigame()
}
    if (cenaId === 'labirinto'){
      document.querySelector(".arena").style.display = "block"
      document.querySelector(".novel").style.display = "none"
      StartLabirinto()
    }
    else { 
      const base = carregarCena(cenaId)
      document.querySelector(".arena").style.display = "none"
      document.querySelector(".novel").style.display = "block"
      document.querySelector(".faladopersonagem").textContent = base.dialogo
      document.querySelector(".avatar").src = base.avatar
      document.querySelector(".cenario").style.backgroundImage = `url(${base.cenario})`
      document.querySelector(".caixadeescolhas").innerHTML = base.opcoes.reduce((html,escolha) => 
      html + `<div class="escolha" onclick="renderizarCena('${escolha.proximaCena}')">${escolha.texto}</div>`, "")
    }
}



//Aqui definimos qual a primeira cena que aparecerá quando a função for chamada, que no caso é a home do jogo
//A ideia é aprimorar mais o jogo
renderizarCena('inicio')

// Adicionamos um botão que vai pra o início do jogo em qualquer momento pra que não haja a necessidade de 
// reiniciar a página toda hora sempre que quisermos voltar atrás na escolha de uma rota 
// Para isso usamos um botão no html onde sua ativação acontece com o addEventListener em que ele
// quando é clicado aciiona o botão que usa a const renzderizarCena pra ir pro início 
//(Ainda precisa ser ajustado)
const voltarInicio = document.querySelector('.btn') 

voltarInicio.addEventListener('click', () => renderizarCena('inicio'))
//A função abaixo limpa a arena usando o innerHTML, fazendo com que os elementos passados 
// sumam da arena e ela seja resetada visualmente
const limparArena = () => {
  const arena = document.querySelector(".arena")
  arena.innerHTML = "" 
}

const StartMinigame = () =>{ 
  
  // função de criação da arena, pega o elemento pelo ID do css e cola diretamente.
const arena = document.getElementById("arena") 

limparArena()

// função de criação da entidade obstaculo!
const gerarObs = (pos) => {
    const o = document.createElement("div")
    o.className = "obst"
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o)
    return o

}

const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "bloco"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
// processo de criação das entidades, onde cada elemento tem seu ID do css e posição baseado nos registros localizados abaixo desse bloco de funções.
}
const criarInimigo = (pos) => {
    const b = document.createElement("div")
    b.className = "inimigo"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
    
}
const criarGameOver = (pos) => {
    const b = document.createElement("div");
    b.className = "gameover"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarTelaInicial = (pos) => {
    const b = document.createElement("div")
    b.className = "TelaInicial"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBrocheCobertor = (pos) => {
    const b = document.createElement("div")
    b.className = "brocheCobertor"
    b.style.left = (pos.x- 5) + "px"
    b.style.top  = (pos.y - 5) + "px"
    arena.appendChild(b)
    return b
}
// bloco de registros onde marca as localizações das entidades geradas
// baseado em um plano cartesiano
const EstadoObst = {x: 100, y:300, height: 50, width: 50} 
const EstadoObst1 = { x: 100, y: 300, width: 50, height: 50 }
const EstadoObst2 = { x: 300, y: 100, width: 50, height: 50 }
const EstadoObst3 = { x: 500, y: 400, width: 50, height: 50 }
const EstadoObst4 = { x: 700, y: 200, width: 50, height: 50 }
const EstadoObst5 = { x: 900, y: 350, width: 50, height: 50 }
const EstadoObst6 = { x: 1100, y: 150, width: 50, height: 50 }
const EstadoObst7 = { x: 600, y: 550, width: 50, height: 50 }
const EstadoObst8 = { x: 1200, y: 500, width: 50, height: 50 }
const EstadoInicial = { x: 650, y: 300, height: 50, width: 50}
const ini2 = {x: 890, y: 500}
const gameoverInicial = {x: 0 , y: 0}
const inimigoInicial = {x:100, y: 20}
// bloco de criação ativa das entidades, pegando as funções e aplicando a posição como parametro.
const InimigoOficial = criarInimigo(inimigoInicial)
const bloco = criarBloco(EstadoInicial)
const estados = [EstadoObst1, EstadoObst2, EstadoObst3, EstadoObst4, EstadoObst5, EstadoObst6, EstadoObst7, EstadoObst8]
// map que gera todos os obstaculos presentes no array estados
const obstaculos = estados.map(estado => gerarObs(estado))
const inim2 = criarInimigo(ini2)
// função de movimentação, que calcula a posição baseado no addEventListener que virá a seguir!
const mover = (estado, tecla) => {
    const passo = 20
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 50
    // delimitação de constantes importantes para o movimento, e colisão com a arena!
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    }
    // registro que guarda a nova posição baseado no addEventlistener!
    const TestarColisão = estados.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)
    if(filtro.length > 0){
    // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
      return estado
    } 
    else {
      return {
        x: Math.min(Math.max(novo.x, 0), maxX),
        y: Math.min(Math.max(novo.y, 0), maxY),
        width: estado.width,
        height: estado.height
      }
    // bloco de função que testa colisão com a entidade obstáculo, como a função colisão foi feita após a movimentação
    // ela é chamada antes mesmo de ser definida, sendo só feita no final do código.
  }
}
  const broches = [
  { x: 750, y: 100 },
  { x: 950, y: 250 },
  { x: 1150, y: 300 }
]
// lista de posição dos broches que vão ser coletados!

const EntidadesBroches = broches.map((broche) => criarBroche(broche))
const loop = (estado, brocheAt,EntBroches) => {
  if (brocheAt.length === 0) {
    clearTimeout(InimigoOficial.timeout)
    clearTimeout(inim2.timeout)
    renderizarCena("ganhouminigame")
    return
  }
  // na ideia recursiva, calcula a quantidade broches restantes
  // a recursão é melhor mostrada um pouco baixo
  const brocheAtual = brocheAt[0]
  // consta as coordenadas do broche atual
  const BrocheEntidadeAtual = EntBroches[0]
  // consta a entidade do broche atual, é importante para retirar e mostrar no CSS
  const filtro = EntBroches.filter((broche) => broche !== BrocheEntidadeAtual)
  // filtra todos os broches para além do broche atual!
  const displayDesligado = filtro.map((broche) => broche.style.display = "none")
  // desliga todos os broches que não são o atual no CSS
  BrocheEntidadeAtual.style.display = "block"
  // liga o display do broche atual


// função que ativamente move o personagem baseado nas coordenadas definidas
// pela função mover!
  document.addEventListener('keydown', (e) => {
    const teclas = ['ArrowRight','ArrowDown','ArrowUp','ArrowLeft']
    if (teclas.includes(e.key)) {
      const novo = mover(estado, e.key)
      const distanciaxb = novo.x - brocheAtual.x
      const distanciayb = novo.y - brocheAtual.y
      const distb = Math.sqrt(distanciaxb **2 + distanciayb ** 2)
      // calculo de distância entre o player e o broche
      bloco.style.left = novo.x + "px"
      bloco.style.top = novo.y + "px"

      if (distb < 50) {
        BrocheEntidadeAtual.style.display = "none"
        loop(novo, brocheAt.slice(1),EntBroches.slice(1)) 
        // após concluir que o player chegou perto suficiente
        // do broche, reinicia a recursão, agora com os próximos
        // broches
      } else {
        loop(novo,brocheAt,EntBroches)
      }
      // caso não reinicia a recursão com os mesmos broches
    }
    else{
      loop(estado,brocheAt,EntBroches)
      // caso não se mova, reinicia a recursão com os mesmos broches 
      // e mesma posição
    }
  },{once:true});
  // processo que permite que a recursão não seja 
  // gerada infinitamente, já que o once true apaga o listener após 
  // ele ser efetuado, mas como esta em um processo recursivo, 
  // ele reinicia, o que impede que dê stack overflow. 
};
// função que realiza o movimento do inimigo!
const moverInimigo = (inimigo, inimigo2) =>{
    const passo = 3
    const blocoX = parseInt(bloco.style.left,10)
    const blocoY = parseInt(bloco.style.top,10)
    const inimigoX = parseInt(inimigo.style.left,10)
    const inimigoY = parseInt(inimigo.style.top,10)
    const inimigoX1 = parseInt(inimigo2.style.left,10)
    const inimigoY1 = parseInt(inimigo2.style.top,10)
     // essa parte é importante, pois retira as coordenadas diretamente do css, 
    // o que torna desnecessário realizar a recursão para atualizar
    // a posição do inimigo!
    const distanciax1 = blocoX - inimigoX1
    const distanciay1 = blocoY - inimigoY1
    const dist1 = Math.sqrt(distanciax1**2 + distanciay1**2) || 1
    const distanciax = blocoX - inimigoX
    const distanciay = blocoY - inimigoY
    const dist = Math.sqrt(distanciax**2 + distanciay**2) || 1
    // calculo de distância importante para mexer a entidade!
    // o ou 1 é importante para impedir divisião por 0  
    if(dist < 50 || dist1 < 50) {
        const pegou = renderizarCena("perdeuminigame")
    // calcula se o inimigo esta proximo o suficiente
    // para te "pegar"
  }

    else{
        const novo = {
        x: inimigoX + (distanciax/dist) * 4.5,
        y: inimigoY + (distanciay/dist) * 4.5
        }
        // caso não, movimenta as coordenadas do inimigo
    inimigo.style.left = novo.x + "px"
    inimigo.style.top  = novo.y + "px"
    // passa as novas coordenadas pro CSS
    const novo2 = {
        x: inimigoX1 + (distanciax1/dist1) * 3,
        y: inimigoY1 + (distanciay1/dist1) * 3
    }
    inimigo2.style.left = novo2.x + "px"
    inimigo2.style.top  = novo2.y + "px"
    // faz a mesma coisa, mas pro outro inimigo
    inimigo.timeout = setTimeout(() => moverInimigo(inimigo, inimigo2), 32)
    inimigo2.timeout = inimigo.timeout
    // set time out, feito para rodar a função a cada 32 milisegundos
  
  } 
}

const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
// função de colisão do tipo AABB clássica!

}
// função de start do jogo, que ve o addEventListener para o Enter
// e inicia as duas funções de start do jogo, o loop e o moverInimigo
const FuncaoStart3 = () =>{
  const CriarTela = criarTelaInicial(gameoverInicial)
  document.addEventListener('keydown',(e) =>{
    if(e.key === 'Enter'){
        CriarTela.style.display = "none"
        loop(EstadoInicial, broches,EntidadesBroches)
        moverInimigo(InimigoOficial,inim2)
      }
    },{once: true})
}
FuncaoStart3()
}

const StartLabirinto = () =>{

limparArena()

const arena = document.getElementById("arena") // Seleciona a arena do jogo

// Função que cria o bloco do jogador baseado no id 'bloco' e suas dimensões definido nos estilos
const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "blocoLab"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Função para criar o broche que deve ser capturado pelo jogador
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Estados iniciais do broche e jogador (do labirinto está em outro arquivo) 
const EstadoInicial = {x: 50, y: 350, width: 20, height: 20}
const BrocheInicial = {x: 1220, y:160}
const gameoverInicial = {x: 0 , y: 0}

// Criação dos elementos iniciais baseados na função e o argumento da posição
const bloco = criarBloco(EstadoInicial)
const broche = criarBroche(BrocheInicial)

// Criação dos obstáculos definidos no arquivo labirinto.js lá no script html
// itera toda lista aplicando a posição de cada registro para gerer um bloco (baseado no estilo do css) e adicionar a arena
labirinto.forEach(pos => {
    const o = document.createElement("div");
    o.className = "obst2";
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o) // obstaculos são adicionados
})

// Função que move o jogador com base na tecla pressionada
const mover = (estado, tecla) => {
    const passo = 10 // distância de movimento por tecla
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 20

    // Calcula nova posição com base na tecla
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    }

    // registro que guarda a nova posição baseado no addEventlistener e testa colisão
    const TestarColisão = labirinto.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)

    // Se houver colisão, retorna estado atual
    if(filtro.length > 0){
      return estado
       // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
    } 
    else {
        // Garante que o jogador fique dentro dos limites da arena caso não haja colisão
        const novo2 = {
            x: Math.min(Math.max(novo.x, 0), maxX),
            y: Math.min(Math.max(novo.y, 0), maxY),
            width: estado.width,
            height: estado.height}
        return novo2
    }
}

// loop principal para ler as teclas e atualizar posição
// ativamente move o personagem baseado nas coordenadas definidas pela função mover
const loop = (estado) => {

    document.addEventListener('keydown', (e) => {
        const teclas = ['ArrowRight','ArrowDown','ArrowUp','ArrowLeft'];
        if (teclas.includes(e.key)) {
            const novo = mover(estado, e.key)
            // observa se a tecla esta inclusa no lista definida e em caso afimativo chama a função de movimentação definida acima
            const blocoX = parseInt(bloco.style.left,10)// converte as as cordenadas do personagem, definida em px, para inteiro na
            const blocoY = parseInt(bloco.style.top,10) // converte as as cordenadas do personagem, definida em px, para inteiro na base 10
            const brochex = parseInt(BrocheInicial.x)
            const brochey = parseInt(BrocheInicial.y)// a mesma ideia pro do personagem
            const distanciaxb = blocoX - brochex
            const distanciayb = blocoY - brochey
            const distb = Math.sqrt(distanciaxb**2 + distanciayb**2)
            // caucula a distancia entre broche e personagem (distancia entyre dois pontos)
            if(distb < 22){
              const destino = renderizarCena('ganhoulabirinto')
              
                // se a distancia for menosr que 22 px o jogo é finalizado e vencido    
            }
            else{
                // caso nao tenha a distancia correta o jogo retorna o loop de movimento com o novo estado
                bloco.style.left = novo.x + "px"
                bloco.style.top  = novo.y + "px"
                loop(novo)
            }
        }
        else{
            // Se tecla não estiver na lista continua o loop sem mover, retornando o mesmo estado
            loop(estado)
        }

    },{once: true}); // Garante que o evento seja escutado uma vez por ciclo
}// processo que permite que a recursão não seja 
  // gerada infinitamente, já que o once true apaga o listener após 
  // ele ser efetuado, mas como esta em um processo recursivo, 
  // ele reinicia, o que impede que dê stack overflow. 


// Função que verifica colisão entre jogador e obstáculo
// colisão do tipo AABB clássica
const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
}

// Inicia o jogo com estado inicial definido
loop(EstadoInicial)

}




</script>
</html>
