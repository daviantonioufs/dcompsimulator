<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCOMP SIMULATOR</title>
    
<style>
body {
    margin: 0;
    height: 100vh;
    display: flex;
    background-image: url("assets/cidadefundosite.jpg");
    background-size: cover;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px); /*Aqui colocamos um webkit pra se adaptar para o macOS*/
  }

.novel{
        display: block;
        box-shadow: 0 0 5px .1px #181818ba;
        width: 878px;
        margin: auto;
        background-color: rgba(255, 255, 255);
        position: relative;
        min-height: 560px;
}

.btn{
        box-sizing: inherit;
        font-family: Arvo, serif;
        background-color: rgb(91, 20, 222);
        text-shadow: 0 1px 2px rgb(50, 13, 118);
        border: none;
        border-bottom-right-radius: 9px;
        border-top-right-radius: 9px;
        background-image: linear-gradient(transparent, rgba(0, 0, 0, 0.2));
        box-shadow: -1px -1px 6.72px .28px #0006;
        padding: 11px 10px 10px 20px;
        color: #fff;
        font-size: 13px;
        font-weight: 700;
        position: absolute;
        top: 7px;
        left: -10px;
        cursor: pointer;
        transition: left 0.3s;
        pointer-events: auto;
        display: inline-block;
}

.cenario{
        width: 878px;
        margin: auto;
        background-color: rgba(255, 255, 255);
        position: absolute;
        background-size: cover;
        min-height: 560px
    }

.caixadeescolhas{
        background-color: rgba(255, 255, 255, 0.85);
        border: 3px solid rgb(91, 20, 222); 
        box-sizing: border-box;
        color: rgb(51, 51, 51);
        line-height: 1.4;
        padding: 15px 20px;
        width: 831px;
        position: absolute;
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 30;
        display: flex;
        flex-direction: column; 
        gap: 10px; 
        margin-top: auto; 
    }

.escolha{
        cursor: pointer;
        background: rgba(255, 255, 255, 0);
        color: rgba(104, 56, 152, 0.85) ;
        padding: 3px 10px 3px 10px;
        line-height: 24px;
        font-size: 18px;
        transition: all 0.3s;
        font-family: Arvo, serif;
    }

.escolha:hover:not([disabled]){
        background: rgba(104, 56, 152);
        color: rgba(255, 255, 255);
    }
  
.personagem {
  position: absolute;
  right: -60px;
  padding: 94px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.avatar{
  width: 311px;   
}

.faladopersonagem {
  background-color: #ffffffd9;
  border-radius: 25px;
  border: 3px solid white;
  box-sizing: content-box;
  font-size: 17px;
  font-weight: normal;
  line-height: 30px;
  padding: 13px 16px;
  position: absolute;
  text-align: left;
  z-index: 20;
  overflow-wrap: break-word;
  top: 26%;
  left: 15.7812%;
  max-width: 27%;
  font-family: Arvo, serif;
}

.obst {
  position: absolute;
  width: 50px;
  height: 50px;
  background: #250bec;
  border-radius: 8px;
  z-index: 4;
}

.obst2 {
  position: absolute;
  width: 40px;
  height: 20px;
  background-image: url('assets/espinhos.png');
  background-size: cover;
  z-index: 4;
}

.blocoLab {
  position: absolute;
  width: 15px;
  height: 15px;
  background: #880afe;
  border-radius: 99px;
}

.arena {
  display: none;
  margin: auto;
  position: relative;
  width: 1300px;
  height: 700px;
  background: #222;
  border: 3px solid #555;
  border-radius: 12px;
  overflow: hidden;
  z-index: 2
}

.bloco {
  position: absolute;
  width: 50px;
  height: 50px;
  background-image: url('assets/personagem_principal_avatar.png');
  background-size: cover;
  border-radius: 8px;
  z-index: 4;
}

.broche {
  position: absolute;
  width: 20px;
  height: 20px;
  background: #ffffff;
  border-radius: 20px;
  z-index: 2;
}

.gameover {
  position: absolute;
  width: 1300px;
  height: 700px;
  background: #ffd700;
  border-radius: 8px;
  z-index: 10;
}

.TelaInicial {
  background-image: url('assets/minigamestarscreen.jpg');
  background-size: cover;
  position: absolute;
  width: 1300px;
  height: 700px;
  border-radius: 8px;
  z-index: 10;
}

.inimigo {
  background-image: url('assets/bigcarlos-bravo.png');
  background-size: cover;
  position: absolute;
  width: 70px;
  height: 70px;
  border-radius: 8px;
  z-index: 4;
}

.brocheCobertor {
  position: absolute;
  width: 30px;
  height: 30px;
  background: #222;
  border-radius: 20px;
  z-index: 3;
}
</style>
</head>
<body>
  <!--Efeitos sonoros e mais músicas adicionadas para novas instâncias, usamos o comando que busca o id da música e colocamos-->
  <!--a ordem da música que deveria parar e qual deveria tocar. Exemplo do comando: nomedamusica.play()-->
  <!--O erro da múscia não tocar ao iniciar o jogo será resolvido até o prazo.-->
    <audio id="musicaFundo" preload="auto" autoplay loop>
    <source src="assets/musicadefundodojogo.mp3" type="audio/mpeg">
    </audio>
    <audio id="musicaMinigame">
    <source src="assets/musicadominigame.mp3" type="audio/mpeg">
    </audio>
    <audio id="musicaLabirinto">
    <source src="assets/musicadolabirinto.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameoverlabirinto">
    <source src="assets/mauscaminhossound.mp3" type="audio/mpeg">
    </audio>
    <audio id="itemcolected">
    <source src="assets/musicadeganharitens.mp3" type="audio/mpeg">
    </audio>
  <!--Aqui definimos os divs onde serão inseridos os elementos que compõem cada cena e instância do jogo-->
    <div class="arena" id="arena"></div>
    <div class="novel">
        <div class="faladopersonagem"></div>
        <div class="cenario"></div>
        <div class="personagem">
            <img class="avatar" src="" alt="avatar"><img>
        </div>
        <div class="caixadeescolhas">
            <div class="escolha"></div>
        </div>
    </div>
    <button class="btn">Início</button>
</body>
<script src="minigame/labirinto.js"></script>
<script>

// Aqui temos a lista com o objeto que representam os personagens, contendo o id deles e o url do avatar que será exibido 
// Implementamos novos personagens: Dcomper (no minigame do AdCoffee), Big C (no minigame do AdCoffee), emoções de personagens
// já conhecidos como Kal-El Freira, que agora tem emoções triste e bravo. Além disso, um personagem vazio foi adicionado
// para cenas onde, devido a funções que sempre recolhem um avatar da cena, não queremos que tenha um avatar.

const personagens = {
   pinguitor: {nome: 'Pinguitor', avatar: 'assets/pinguitor.png'},
   goodways: {nome: 'Good Ways', avatar: 'assets/goodways.png'},
   kalelfreira: {nome: 'Kal-El Freira', avatar: 'assets/kal-elfeliz.png'},
   kalelfreirabravo: {nome: 'Kal-El Freira', avatar: 'assets/kal-elbravo.png'},
   kalelfreiratriste: {nome: 'Kal-El Freira', avatar: 'assets/kal-eltriste.png'},
   bigc: {nome: 'Big C', avatar: 'assets/bigcarlos-triste.png'},
   nobody: {nome: 'nobody', avatar: 'assets/nobody.png'},
}

// Aqui criamos outra lista que contém as cenas. Elas detalham o personagem pelo id da lista anterior (puxa o avatar e o nome do personagem)
// Além disso ele determina o cenário da cena, o diálogo a ser exibido e um array com as diferentes opções.
// Colocamos novos cenários!

const cenas = {
  
  inicio: {
    personagem: 'pinguitor',
    cenario: 'assets/fundo_ufs.jpg',
    dialogo: 'Olá! Seja bem-vindo ao DCOMP! Eu sou o Pinguitor, líder do clã Bugados e serei seu guia. Escolha uma das rotas para conhecer mais sobre as aventuras do curso:',
    opcoes: [
      {opcao: 1, texto: 'A. Rota do Peregrino' , proximaCena: 'olagoodways'},
      {opcao: 2, texto: 'B. Rota do Arauto das Normas' , proximaCena: 'olakalelfreira'}, //tinhamos cometido um erro no nome da rota
      {opcao: 3, texto: 'C. Rota do AdCoffee' , proximaCena: 'uminimigoteespera'}//mudança no nome da rota
    ]
  },

  olagoodways: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Dcomper, viva! Hoje te guiarei pelos bons caminhos da nossa grande universidade!',
    opcoes: [
      {opcao: 1, texto: 'A. Ok... mas qual seu nome?' , proximaCena: 'apresentacaogoodways'}
    ]
  },

  apresentacaogoodways: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Perdoe-me! Meu nome é Good Ways e sou professor do DCOMP, além de secretário regional da SBC!',
    opcoes: [
      {opcao: 1, texto: 'A. Prazer! Mas o que é SBC?' , proximaCena: 'explicacaosbc'}
    ]
  },

  explicacaosbc: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'A SBC é a Sociedade Brasileira de Computeiros: é ela que contribui desde a formação da grade dos cursos à eventos da área!',
    opcoes: [
      {opcao: 1, texto: 'A. Legal... Mas quando vamos começar os "Bons Caminhos"?' , proximaCena: 'comecodajornada'}
    ]
  },

  comecodajornada: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Pelo visto você sabe! Bom, já que insiste, lhe mostrarei os bons caminhos. É bem simples até.',
    opcoes: [
      {opcao: 1, texto: 'A. (Próxima Cena)' , proximaCena: 'explicacaodolabirinto'}
    ]
  },

  explicacaodolabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Consiste em um labirinto que te levará direto para o segredo de como codar melhor e se tornar um verdadeiro dcomper.',
    opcoes: [
      {opcao: 1, texto: 'A. (Próxima Cena)' , proximaCena: 'vamospraolabirinto'}
    ]
  },

vamospraolabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Se você encostar nos espinhos, os maus caminhos despertam minha ira, então tome cuidado! Está pronto?',
    opcoes: [
      {opcao: 1, texto: 'A. Com certeza!' , proximaCena: 'labirinto'}
    ]
  },

  ganhoulabirinto: {
    personagem: 'goodways',
    cenario: 'assets/ufs_resun.jpg',
    dialogo: 'Dcomper, viva! Você concluiu a missão com êxito, aqui está:',
    opcoes: [
      {opcao: 1, texto: 'A. (Pegar o Pergaminho do Poderoso Dev)' , proximaCena: 'pergaminho'}
    ]
  },

  pergaminho: {
    personagem: 'nobody',
    cenario: 'assets/pergaminhododev.jpg',
    dialogo: 'Você adquiriu o Pergaminho do Poderoso Dev',
    opcoes: [
      {opcao: 1, texto: 'A. (Voltar ao início)' , proximaCena: 'reset'}
    ]
  },
  
  perdeulabirinto: {
    personagem: 'nobody',
    cenario: 'assets/mauscaminhos.jpg',
    dialogo: 'VOCÊ INVOCOU A IRA DO BADWAYS. O QUE FARÁ AGORA?',
    opcoes: [
      {opcao: 1, texto: 'A. (Tentar outra vez)' , proximaCena: 'labirinto'},
      {opcao: 2, texto: 'B. (Voltar ao início)' , proximaCena: 'reset'}
    ]
  },
  
   olakalelfreira: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Olá, dcomper! Me chamo Kal-el Freira e lhe ensinarei sobre o conjunto de normas que rege esta Cidade Universitária!',
    opcoes: [
      {opcao: 1, texto: 'A. É tipo etiqueta?' , proximaCena: 'aufseumaselva'}
    ]
  },

  aufseumaselva: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Não! Vamos lá: imagine que a UFS é um selva. Aqui você encontrará todo tipo de bicho: do mais pacífico até o mais feroz',
    opcoes: [
      {opcao: 1, texto: 'A. Eita, pêga! Mas o que as normas tem a ver com isso?' , proximaCena: 'kalelexplicaasnormas'}
    ]
  },

  kalelexplicaasnormas: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Elas são os artefatos que lhe protegem desses predadores e garante o sucesso em sua jornada!',
    opcoes: [
      {opcao: 1, texto: 'A. Como eu consigo as normas?' , proximaCena: 'kaleltedaumamissao'}
    ]
  },

  kaleltedaumamissao: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Sou eu quem as guardo! Mas para te dar as normas vou te fazer perguntas e se responder corretamente, você terá a chave para as normas!',
    opcoes: [
      {opcao: 1, texto: 'A. Moleza, moleza' , proximaCena: 'kaleldaumaviso'}
    ]
  },

    kaleldaumaviso: {
    personagem: 'kalelfreirabravo',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Não se engane, jovem! Você verá que esse desafio não é um mero jogo, se errar você será JUBILADO!',
    opcoes: [
      {opcao: 1, texto: 'A. Tá, vamo lá...' , proximaCena: 'pergunta1'}
    ]
  },

  pergunta1: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Vamos lá: qual a regra da toalha, segundo o livro "O Guia do Mochileiro das Galáxias" de Douglas Adams?',
    opcoes: [
      {opcao: 1, texto: 'A. A toalha é o item mais valioso do mochileiro interestelar, pois serve como agasalho, arma, proteção e, claro, para se secar.' , proximaCena: 'pergunta2'},
      {opcao: 2, texto: 'B. A regra da toalha diz que só se pode usar a toalha em planetas que tenham atmosfera com exatamente 21% de oxigênio.', proximaCena: 'telaerouu'},
      {opcao: 3, texto: 'C. A regra da toalha determina que ela deve ser sempre colorida de azul para que proteja contra radiação cósmica.', proximaCena: 'telaerouu'},
    ]
  },

  pergunta2: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Aí sim! Agora para próxima: Um professor pode colocar uma arma na mesa e ameaçar a turma por um aluno ter colado?',
    opcoes: [
      {opcao: 1, texto: 'A. Claro que sim! As normas devem dizer que medidas cabíveis podem ser tomadas.', proximaCena: 'telaerouu'},
      {opcao: 2, texto: 'B. É possível. Até porque o regimento da universade deve ser diferente da lei fora dela', proximaCena: 'telaerouu'},
      {opcao: 3, texto: 'C. Claro que não. Independente de normas, é crime ameaçar as pessoas com arma de fogo.' , proximaCena: 'pergunta3'}
    ]
  },

  pergunta3: {
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Ufa! Pensei que iria errar. Agora a última e mais fácil: qual a derivada de (sen(x))^2?',
    opcoes: [
      {opcao: 1, texto: 'A. 2 sen(x)', proximaCena: 'telaerouu'},
      {opcao: 2, texto: 'B. 2sen(x)cos(x)', proximaCena: 'venceuquiz'},
      {opcao: 3, texto: 'C. -2sen(x)cos(x)' , proximaCena: 'telaerouu'}
    ]
  },

  telaerouu: {
    personagem: 'kalelfreiratriste',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Você foi jubilado! Não poderá conhecer as normas, mas pode tentar de novo ou escolher outra rota:',
    opcoes: [
      {opcao: 1, texto: 'A. (Reiniciar)', proximaCena: 'pergunta1'},
      {opcao: 2, texto: 'B. (Escolher outra rota)', proximaCena: 'reset'}
    ]
  },

  venceuquiz:{
    personagem: 'kalelfreira',
    cenario: 'assets/ufs_reitoria.jpg',
    dialogo: 'Você concluiu o desafio. Agora entre pela porta para ter acesso as runas nôrmicas:',
    opcoes: [
      {opcao: 1, texto: 'A. (Entrar na porta)', proximaCena: 'normasachivment'}
    ]
  },

  normasachivment: {
    personagem: 'nobody',
    cenario: 'assets/altarnormas.jpg',
    dialogo: null,
    opcoes: [
      {opcao: 1, texto: 'A. (Escolher outra rota)', proximaCena: 'reset'}
    ]
  },

    uminimigoteespera: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Aqui reza a lenda de que você consegue café de graça, mas existe um inimigo poderoso. Você quer enfrentá-lo?',
    opcoes: [
      {opcao: 1, texto: 'A. Vamos nessa!' , proximaCena: 'minigame'}
    ]
  },
  
  ganhouminigame: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Você conseguiu! Siga pela porta pra pegar sua recompensa!',
    opcoes: [
      {opcao: 1, texto: 'A. (Entrar no AdCoffee)' , proximaCena: 'pegarcafe'}
    ]
  },

  pegarcafe: {
    personagem: 'bigc',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Tenho que admitir minha derrota, aqui está jovem!',
    opcoes: [
      {opcao: 1, texto: 'A. (Pegar café)' , proximaCena: 'cafe'}
    ]
  },

  cafe: {
    personagem: 'nobody',
    cenario: 'assets/fotocafe.jpg',
    dialogo: 'Você obteve o café do AdCoffee! Volte para o início para beber o café',
    opcoes: [
      {opcao: 1, texto: 'A. (Beber café)' , proximaCena: 'reset'}
    ]
  },

  reset: {
    personagem: 'nobody',
    cenario: 'assets/fotocafe.jpg',
    dialogo: 'Você resetou o EventListener!',
    opcoes: [
      {opcao: 1, texto: 'A. (Vai voltar tudo, não importa)' , proximaCena: 'reset'}
    ]
  },
  
  perdeuminigame: {
    personagem: 'pinguitor',
    cenario: 'assets/ufs_adufs.jpg',
    dialogo: 'Não foi dessa vez. O que pretende fazer?',
    opcoes: [
      {opcao: 1, texto: 'A. Revanche!' , proximaCena: 'minigame'},
      {opcao: 2, texto: 'B. Escolher outra rota' , proximaCena: 'reset'} // Erro sutil corrigido, as opções estavam com o mesmo número
    ]
  }
}


// Essa função procura no objeto "cenas" um id correspondente com a cena e retorna os elementos pedidos. 
// Optamos por usar "cenas" como um objeto ao invés de um array pela praticidade buscar o id
// sem ter que buscar pela posição (como por exemplo cenas.cenario[0]), indo diretamente 
// em busca da string do nome da cena.
const carregarCena = (idCena) => {
    const cena = cenas[idCena]
    const personagem = personagens[cena.personagem]
    return {
        avatar: personagem.avatar,
        dialogo: cena.dialogo,
        cenario: cena.cenario,
        opcoes: cena.opcoes
    }
  }

// Essa função, por sua vez, utiliza os elementos passados por carregarCena através do id da cena 
// e usa o querySelector para atualizar os elementos no DOM. Usa o reduce pra concatenar 
// as respostas como botões clicáveis, que envia o id pra passar de cena e exibe o texto da 
// escolha da cena para o jogador identificar as opções. Porém, há condições em que caso o jogador
// avance para cenas específicas, elas reproduzirão sons específicos ou então desativaram os elementos
// da novel no CSS e ativaram a arena do Minigame e do Labirinto, que são a mesma arena, mas com itens
// a mais e itens a menos
const renderizarCena = (cenaId) => {
    if (cenaId === 'minigame') {
      document.querySelector(".arena").style.display = "block"
      document.querySelector(".novel").style.display = "none"
      StartMinigame()
}
    if (cenaId === 'labirinto'){
      document.querySelector(".arena").style.display = "block"
      document.querySelector(".novel").style.display = "none"
      StartLabirinto()
    }

    if (cenaId === 'pergaminho') {
      musicaFundo.pause()
      musicaFundo.loop = false
      itemcolected.play()
      const base = carregarCena(cenaId)
      document.querySelector(".arena").style.display = "none"
      document.querySelector(".novel").style.display = "block"
      document.querySelector(".faladopersonagem").textContent = base.dialogo
      document.querySelector(".avatar").src = base.avatar
      document.querySelector(".cenario").style.backgroundImage = `url(${base.cenario})`
      document.querySelector(".caixadeescolhas").innerHTML = base.opcoes.reduce((html,escolha) => 
      html + `<div class="escolha" onclick="renderizarCena('${escolha.proximaCena}')">${escolha.texto}</div>`, "")
    }

    if (cenaId === 'cafe') {
      musicaFundo.pause()
      musicaFundo.loop = false
      itemcolected.play()
      const base = carregarCena(cenaId)
      document.querySelector(".arena").style.display = "none"
      document.querySelector(".novel").style.display = "block"
      document.querySelector(".faladopersonagem").textContent = base.dialogo
      document.querySelector(".avatar").src = base.avatar
      document.querySelector(".cenario").style.backgroundImage = `url(${base.cenario})`
      document.querySelector(".caixadeescolhas").innerHTML = base.opcoes.reduce((html,escolha) => 
      html + `<div class="escolha" onclick="renderizarCena('${escolha.proximaCena}')">${escolha.texto}</div>`, "")
    }

    else if (cenaId === 'reset'){window.location.reload()}

    else { 
      const base = carregarCena(cenaId)
      document.querySelector(".arena").style.display = "none"
      document.querySelector(".novel").style.display = "block"
      document.querySelector(".faladopersonagem").textContent = base.dialogo
      document.querySelector(".avatar").src = base.avatar
      document.querySelector(".cenario").style.backgroundImage = `url(${base.cenario})`
      document.querySelector(".caixadeescolhas").innerHTML = base.opcoes.reduce((html,escolha) => 
      html + `<div class="escolha" onclick="renderizarCena('${escolha.proximaCena}')">${escolha.texto}</div>`, "")
    }

     
}

// Aqui definimos qual a primeira cena que aparecerá quando a função renderizarCena 
// for chamada, que no caso é a início do jogo.

renderizarCena('inicio')

// Nota atualiza:
// Adicionamos um botão que vai para o início do jogo a qualquer momento, pra que não haja a necessidade de 
// reiniciar a página usando F5 ou apertando o atualizar da página sempre que quisermos voltar atrás na escolha de uma rota 
// Para isso usamos um botão no HTML onde sua ativação acontece com o addEventListener em que ele,
// quando é clicado, adiciona o botão que usa o comando window.location.reload pra recarregar toda a página. 
// Ajuste final feito: agora o inicio e a seção de escolha de rotas são uma tela só, logo o jogo
// vai para o início sempre que vai pra tela de escolha, eliminando bugs.

const voltarInicio = document.querySelector('.btn')
voltarInicio.addEventListener('click', () => window.location.reload())

// A função abaixo limpa a arena usando o innerHTML, fazendo com que os elementos passados 
// sumam da arena e ela seja resetada visualmente

const limparArena = () => {
  const arena = document.querySelector(".arena")
  arena.innerHTML = "" 
}

const StartMinigame = () =>{ 
  
// Função de criação da arena, faz o pull (coletar ou puxar) do elemento pelo id do CSS e o cola diretamente, 
// além de limpa-lá, evitando que, caso o jogador queira uma "Revanche" os elementos que estevam na tela
// no momento em que o jogador perdeu o jogo sejam retirados da arena.

limparArena()

// Função de criação da entidade obstaculo!

const gerarObs = (pos) => {
    const o = document.createElement("div")
    o.className = "obst"
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o)
    return o

}
const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "bloco"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
// processo de criação das entidades, onde cada elemento tem seu ID do css e posição baseado nos registros localizados abaixo desse bloco de funções.
};
const criarInimigo = (pos) => {
    const b = document.createElement("div")
    b.className = "inimigo"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
    
}
const criarGameOver = (pos) => {
    const b = document.createElement("div")
    b.className = "gameover"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarTelaInicial = (pos) => {
    const b = document.createElement("div")
    b.className = "TelaInicial"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBrocheCobertor = (pos) => {
    const b = document.createElement("div")
    b.className = "brocheCobertor"
    b.style.left = (pos.x- 5) + "px"
    b.style.top  = (pos.y - 5) + "px"
    arena.appendChild(b)
    return b
}
// bloco de registros onde marca as localizações das entidades geradas
// baseado em um plano cartesiano
const EstadoObst = {x: 100, y:300, height: 50, width: 50} 
const EstadoObst1 = { x: 100, y: 300, width: 50, height: 50 }
const EstadoObst2 = { x: 300, y: 100, width: 50, height: 50 }
const EstadoObst3 = { x: 500, y: 400, width: 50, height: 50 }
const EstadoObst4 = { x: 700, y: 200, width: 50, height: 50 }
const EstadoObst5 = { x: 900, y: 350, width: 50, height: 50 }
const EstadoObst6 = { x: 1100, y: 150, width: 50, height: 50 }
const EstadoObst7 = { x: 600, y: 550, width: 50, height: 50 }
const EstadoObst8 = { x: 1200, y: 500, width: 50, height: 50 }
const EstadoInicial = { x: 650, y: 300, height: 50, width: 50}
const ini2 = {x: 890, y: 500}
const gameoverInicial = {x: 0 , y: 0}
const inimigoInicial = {x:100, y: 20}
// bloco de criação ativa das entidades, pegando as funções e aplicando a posição como parametro.
const InimigoOficial = criarInimigo(inimigoInicial)
const bloco = criarBloco(EstadoInicial)
const estados = [EstadoObst1, EstadoObst2, EstadoObst3, EstadoObst4, EstadoObst5, EstadoObst6, EstadoObst7, EstadoObst8];
// map que gera todos os obstaculos presentes no array estados
const obstaculos = estados.map(estado => gerarObs(estado));
const inim2 = criarInimigo(ini2)
// função de movimentação, que calcula a posição baseado no addEventListener que virá a seguir!
const mover = (estado, tecla) => {
    const passo = 20
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 50
    // delimitação de constantes importantes para o movimento, e colisão com a arena!
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    };
    // registro que guarda a nova posição baseado no addEventlistener!
    const TestarColisão = estados.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)
    if(filtro.length > 0){
    // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
      return estado
    } 
    else {
      return {
        x: Math.min(Math.max(novo.x, 0), maxX),
        y: Math.min(Math.max(novo.y, 0), maxY),
        width: estado.width,
        height: estado.height
      }
    // caso não exista colisão com o obstaculo, testa a colisão com a arena
    // e retorna ou a nova movimentação, ou o maximo da arena!
  }
}
  const broches = [
  { x: 50, y: 50 },
 { x: 1150, y: 300 },
  { x: 250, y: 200 },
  { x: 100, y: 400 },
  { x: 300, y: 200 },
  { x: 600, y: 100 },
  { x: 1250, y: 400 },
  { x: 200, y: 500 },
  { x: 800, y: 250 },
  { x: 350, y: 50 },
  { x: 950, y: 250 },
]
// lista de posição dos broches que vão ser coletados!

const EntidadesBroches = broches.map((broche) => criarBroche(broche))
// map que cria cada broche como entidade baseado na função CriarBroche
// baseado em cada registro do array broches.
const MoverPersonagem = (estado,broches,EntBroches) => {
  document.addEventListener('keydown', (e) => {
  // Escutador de eventos que mapeia qual tecla esta sendo pressionada!
      const novo = mover(estado, e.key)
      // nova constante que aplica a função mover
      // ao estado atual, tendo como paramêtro a tecla pressionada
      renderPersonagem(novo)
      // aplica a função impura que mexe no DOM 
      // e pinta o bloco na nova posição no CSS
      if(ColetaDeBroches(novo,broches,EntBroches) === true){
        
        MoverPersonagem(novo,broches.slice(1),EntBroches.slice(1))
      }
      // implementação recursiva que chama a função Coleta de Broches
      // caso o personagem toque o broche, aplica a função para a proxima
      // posição do array.
      else{
        document.removeEventListener('keydown', (e))
        MoverPersonagem(novo,broches,EntBroches)
        // caso não, mantém o broche atual!
      }
  }, {once:true}) // aplicação do AddEventListener que apaga o listener após o evento ser ativado
  // porém, por estar em um processo recursivo, o Listener retorna, isso impede que entre em um processo 
  // de recursão infinita e trave o navegador!
}
// função que movimenta o primeiro inimigo!
const moverInimigo = (player,inimigo) =>{
    const velocidade = 3
    const PlayerX = parseInt(player.style.left,10)
    const PlayerY = parseInt(player.style.top,10)
    const inimigoX = parseInt(inimigo.style.left,10)
    const inimigoY = parseInt(inimigo.style.top,10)
    // constantes importantes que consta a velocidade, e a
    // posição atual do player e do inimigo!
    const distanciax = PlayerX - inimigoX
    const distanciay = PlayerY - inimigoY
    const dist = Math.sqrt(distanciax**2 + distanciay**2) || 1
    // calculo do vetor (matemático) da distância entre o player e
    // o inimigo!
    if(dist < 50){
        musicaMinigame.pause()
        musicaMinigame.loop = false
        musicaFundo.play()
        const pegou = renderizarCena("perdeuminigame")
        // caso o vetor distância seja menor que 50, consta que o 
     // player foi pego e para a movimentação!
     } 
   else{
     return {
      x: inimigoX + (distanciax/dist) * velocidade,
      y: inimigoY + (distanciay/dist) * velocidade
    }
    // caso não, retorna uma nova coordenada 
    // onde a posição atual é somada a multiplicação 
    // do vetor normalizado com a velocidade do inimigo!
  }
}
const moverInimigo2 = (player,inimigo) =>{
    // essa função acaba sendo igual a função anterior
    // mas com velocidades diferentes, o que é importante
    // pois caso não os inimigos depois de um tempo acabam se 
    // fundindo!
    const velocidade = 5
    const blocoX = parseInt(player.style.left,10)
    const blocoY = parseInt(player.style.top,10)
    const inimigoX = parseInt(inimigo.style.left,10)
    const inimigoY = parseInt(inimigo.style.top,10)
    const distanciax = blocoX - inimigoX
    const distanciay = blocoY - inimigoY
    const dist = Math.sqrt(distanciax**2 + distanciay**2) || 1

    if(dist < 50){
        musicaMinigame.pause()
        musicaMinigame.loop = false
        musicaFundo.play()
        const pegou = renderizarCena("perdeuminigame")
  } 
  else{
    return {
      x: inimigoX + (distanciax/dist) * velocidade,
      y: inimigoY + (distanciay/dist) * velocidade
    }
  }
}
const render = (player,inimigo1,inimigo2) =>{
  const novo1 = moverInimigo(player,inimigo1)
  const novo2 = moverInimigo2(player,inimigo2)
  inimigo1.style.left = novo1.x + 'px'
  inimigo1.style.top = novo1.y + 'px'
  inimigo2.style.left = novo2.x + 'px'
  inimigo2.style.top = novo2.y + 'px'
  inimigo1.timeout = setTimeout(() => render(player,inimigo1, inimigo2), 32)
  inimigo2.timeout = inimigo1.timeout
  // função impura que mexe no DOM para renderizar cada inimigo
  // pegando as coordenadas que saem de cada função e passam
  // para o CSS
  // set time out permite que a posição do inimigo seja atualizada baseada no tempo determinado, nese caso o inimigo 2 acaba sendo referenciado com o primeiro
}
const renderPersonagem = (estado) =>{
  bloco.style.left = estado.x + "px"
  bloco.style.top = estado.y + "px"
  // função que mexe no DOM e renderiza o player
}
const FunçãoAuxiliarColeta = (listaQualquer) =>{
  return listaQualquer.map((x) => x.style.display = "none")
}
// função auxiliar que desliga a imagem de uma lista de elementos!
const FunçãoAuxiliarColeta2 = (x) =>{
  return x.style.display = "block"
}
// função auxiliar que liga a imagem de algum elemento!
const FunçãoAuxiliarColeta3 = (x) =>{
  return x.style.display = "none"
}
// função auxiliar que desliga a imagem de algum elemento!
FunçãoAuxiliarColeta(EntidadesBroches)
const ColetaDeBroches = (estado,estadosBroches, ElementosBroches) =>{
  if(estadosBroches.length === 0){
    musicaMinigame.pause()
    musicaMinigame.loop = false
    musicaFundo.play()
    clearTimeout(InimigoOficial.timeout)
    clearTimeout(inim2.timeout)
    renderizarCena("ganhouminigame")
    return
}
// como acaba sendo aplicado em um processo
// recursivo, precisa do caso base, que no caso
// é quando todos os broches são coletado
//nesse caso quando chega a 0, o settime out é apagado o que evita um bug de perder mesmo ao ganhar, em suma faz os inimigos 
// pararem depois que todos os broches são coletado, então o jogo não é de fato terminado. apenas o sistema de movimentação para de ser chamado a cada 32 ms

  const CoordenadasBrocheAtual = estadosBroches[0]
  const EntidadeBrocheAtual = ElementosBroches[0]
// só constantes necessárias para acessar o broche específico!

  FunçãoAuxiliarColeta2(EntidadeBrocheAtual)
  // liga o display do broche atual, é importante no processo recursivo
  // por que o que virá abaixo vai desligar o display, então acabava que 
  // apartir do primeiro todos ficavam desligados, o que não era a ideia.

  const filtro = ElementosBroches.filter((broche) => broche !== EntidadeBrocheAtual)
  FunçãoAuxiliarColeta(filtro)
  // desliga todos os displays que não são o broche atual
  
  const distanciax = CoordenadasBrocheAtual.x - estado.x
  const distanciay = CoordenadasBrocheAtual.y - estado.y
  const dist = Math.sqrt(distanciax**2 + distanciay**2)
  // calculo de vetor distância do mesmo jeito dos inimigos
  // mas só calcula a distância mesmo
  if(dist < 50){
    FunçãoAuxiliarColeta3(EntidadeBrocheAtual)
    return true
  }
  else{
    return false
  }
  // retorna true ou false que é trabalhado la na função
  // mover personagem!
}
const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
// função de colisão do tipo AABB clássica! baseado no tutorial
// disponível em: https://tutorialedge.net/gamedev/aabb-collision-detection-tutorial/
}
// função de start do jogo, que ve o addEventListener para o Enter
// e inicia as duas funções de start do jogo, o loop e o moverInimigo
const CriarTela = criarTelaInicial(gameoverInicial)
const FuncaoStart = () =>{
  document.addEventListener('keydown',(e) =>{
    if(e.key === 'Enter'){
        FunçãoAuxiliarColeta3(CriarTela)
        MoverPersonagem(EstadoInicial,broches,EntidadesBroches)
        render(bloco,InimigoOficial,inim2)
        musicaFundo.pause()
        musicaMinigame.play()
        musicaMinigame.loop = true
      }
      else{
        FuncaoStart()
      }
    },{once: true})
}
// Função de Start do jogo, que liga as funções necessárias
// para iniciar o jogo após o evento 'Enter'.
FuncaoStart()
}

    
const StartLabirinto = () => {

limparArena()


const arena = document.getElementById("arena") // Seleciona a arena do jogo

// Função que cria o bloco do jogador baseado no id 'bloco' e suas dimensões definido nos estilos
const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "blocoLab"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Função para criar o broche que deve ser capturado pelo jogador
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Estados iniciais do broche e jogador (do labirinto está em outro arquivo) 
const EstadoInicial = {x: 50, y: 350, width: 20, height: 20}
const BrocheInicial = {x: 1140, y: 325}
const gameoverInicial = {x: 0 , y: 0}

// Criação dos elementos iniciais baseados na função e o argumento da posição
const bloco = criarBloco(EstadoInicial)
const broche = criarBroche(BrocheInicial)

// Criação dos obstáculos definidos no arquivo labirinto.js lá no script html
// itera toda lista aplicando a posição de cada registro para gerer um bloco (baseado no estilo do css) e adiciona a arena
labirinto.forEach(pos => {
    const o = document.createElement("div");
    o.className = "obst2";
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o) // obstaculos são adicionados
})

// Função que move o jogador com base na tecla pressionada
const mover = (estado, tecla) => {
    const passo = 10 // distância de movimento por tecla
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 20

    // Calcula nova posição com base na tecla
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    }

    // registro que guarda a nova posição baseado no addEventlistener e testa colisão
    const TestarColisão = labirinto.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)

    // Se houver colisão, retorna estado atual
    if(filtro.length > 0){
      musicaLabirinto.pause()
      musicaLabirinto.loop = false
      gameoverlabirinto.play()
      return renderizarCena("perdeulabirinto")
       // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
    } 
    else {
        // Garante que o jogador fique dentro dos limites da arena caso não haja colisão
        const novo2 = {
            x: Math.min(Math.max(novo.x, 0), maxX),
            y: Math.min(Math.max(novo.y, 0), maxY),
            width: estado.width,
            height: estado.height}
        return novo2
    }
}
const RenderPersonagem2 = (player,estado) =>{
    player.style.left = estado.x + 'px'
    player.style.top = estado.y + 'px'
}
// renderiza o player

// loop principal para ler as teclas e atualizar posição
// ativamente move o personagem baseado nas coordenadas definidas pela função mover
const MoverPersonagem = (player,estado) => {
    document.addEventListener('keydown', (e) => {
      const novo = mover(estado, e.key)
      // aplica a função mover baseado na tecla!
      const distanciaxb = novo.x - BrocheInicial.x
      const distanciayb = novo.y - BrocheInicial.y
     const distb = Math.sqrt(distanciaxb**2 + distanciayb**2)
      // calculo de distância entre o broche e o estado atual
      if(distb < 22){
        // calcula se o player ta perto o suficiente para constar
        // se o broche pode ser coletado
        musicaLabirinto.pause()
        musicaLabirinto.loop = false
        musicaFundo.play()
        const destino = renderizarCena('ganhoulabirinto')
        return
      }
      else{
        RenderPersonagem2(player,novo)
        // caso não, renderiza o player na nova posição, baseado na
        // função render
        MoverPersonagem(player,novo)
        // reinicia a recursão com a nova posição como parâmetro
      }
    },{once: true}) // conjectura que apaga o listener após ser usado
} // mas como esta em uma recursão o listener é reativado, esse once: true,
// permite que os listeners não sejam empilhados, fazendo com que o navegador 
// não trave!


const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
}
// o mesmo sistema de colisão anterior, baseado no tutorial
// disponivel em: https://tutorialedge.net/gamedev/aabb-collision-detection-tutorial/

// Inicia o jogo com estado inicial definido

MoverPersonagem(bloco,EstadoInicial)
musicaFundo.pause()
musicaLabirinto.play()
musicaLabirinto.loop = true
}
</script>
</html>

