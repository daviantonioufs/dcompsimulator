<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Labirinto Puzzle</title>
<style>

  /* Estilização do corpo da página */
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #111;
  }

  /* Estilo dos obstáculos */
  .obst {
    position: absolute;
    width: 40px;
    height: 20px;
    background: #250bec;
    border-radius: 0px;
  }

  /* Estilo da arena principal do jogo */
  .arena {
    position: relative;
    width: 1300px;
    height: 700px;
    background: #222;
    border: 3px solid #555;
    border-radius: 12px;
    overflow: hidden;
  }

  /* Estilo do jogador */
  .bloco {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #880afe;
    border-radius: 99px;
  }

  /* Estilo do broche */ 
  .broche {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #f20808;
    border-radius: 99px;
  }


</style>
</head>
<body>
  <div class="arena" id="arena"></div>

<script src="labirinto.js"></script> 
<script>

const arena = document.getElementById("arena") // Seleciona a arena do jogo

// Função que cria o bloco do jogador baseado no id 'bloco' e suas dimensões definido nos estilos
const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "bloco"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Função para criar o broche que deve ser capturado pelo jogador
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b) // aqui adiciona ele a arena
    return b
}

// Estados iniciais do broche e jogador (do labirinto está em outro arquivo) 
const EstadoInicial = {x: 50, y: 350, width: 20, height: 20}
const BrocheInicial = {x: 1140, y: 325}
const gameoverInicial = {x: 0 , y: 0}

// Criação dos elementos iniciais baseados na função e o argumento da posição
const bloco = criarBloco(EstadoInicial)
const broche = criarBroche(BrocheInicial)

// Criação dos obstáculos definidos no arquivo labirinto.js lá no script html
// itera toda lista aplicando a posição de cada registro para gerer um bloco (baseado no estilo do css) e adicionar a arena
labirinto.forEach(pos => {
    const o = document.createElement("div");
    o.className = "obst";
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o) // obstaculos são adicionados
})

// Função que move o jogador com base na tecla pressionada
const mover = (estado, tecla) => {
    const passo = 10 // distância de movimento por tecla
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 20

    // Calcula nova posição com base na tecla
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    }

    // registro que guarda a nova posição baseado no addEventlistener e testa colisão
    const TestarColisão = labirinto.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)

    // Se houver colisão, retorna estado atual
    if(filtro.length > 0){
      return estado
       // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
    } 
    else {
        // Garante que o jogador fique dentro dos limites da arena caso não haja colisão
        const novo2 = {
            x: Math.min(Math.max(novo.x, 0), maxX),
            y: Math.min(Math.max(novo.y, 0), maxY),
            width: estado.width,
            height: estado.height}
        return novo2
    }
}
const RenderPersonagem2 = (player,estado) =>{
    player.style.left = estado.x + 'px'
    player.style.top = estado.y + 'px'
}
// renderiza o player

// loop principal para ler as teclas e atualizar posição
// ativamente move o personagem baseado nas coordenadas definidas pela função mover
const MoverPersonagem = (player,estado) => {
    document.addEventListener('keydown', (e) => {
      const novo = mover(estado, e.key)
      // aplica a função mover baseado na tecla!
      const distanciaxb = novo.x - BrocheInicial.x
      const distanciayb = novo.y - BrocheInicial.y
     const distb = Math.sqrt(distanciaxb**2 + distanciayb**2)
      // calculo de distância entre o broche e o estado atual
      if(distb < 22){
        // calcula se o player ta perto o suficiente para constar
        // se o broche pode ser coletado
        return
      }
      else{
        RenderPersonagem2(player,novo)
        // caso não, renderiza o player na nova posição, baseado na
        // função render
        MoverPersonagem(player,novo)
        // reinicia a recursão com a nova posição como parâmetro
      }
    },{once: true}) // conjectura que apaga o listener após ser usado
} // mas como esta em uma recursão o listener é reativado, esse once: true,
// permite que os listeners não sejam empilhados, fazendo com que o navegador 
// não trave!


const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
}
// o mesmo sistema de colisão anterior, baseado no tutorial
// disponivel em: https://tutorialedge.net/gamedev/aabb-collision-detection-tutorial/

// Inicia o jogo com estado inicial definido
MoverPersonagem(bloco,EstadoInicial)

</script>
</body>
</html>
