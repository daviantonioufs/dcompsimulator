<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Jogo funcional do Big C</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #111;
    z-index: 1;
  }
  .obst {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #250bec;
    border-radius: 8px;
    z-index: 4;
  }
  .arena {
    position: relative;
    width: 1300px;
    height: 700px;
    background: #222;
    border: 3px solid #555;
    border-radius: 12px;
    overflow: hidden;
    z-index: 2;
  }

  .bloco {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #0aee5d;
    border-radius: 8px;
    z-index: 4;
  }
    .broche {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #f20808;
    border-radius: 20px;
    z-index: 2;
    }
    .gameover {
    position: absolute;
    width: 100%;
    height: 100%;
    background: #ffd700;
    border-radius: 8px;
    z-index: 10;
  }
    .TelaInicial {
    position: absolute;
    width: 100%;
    height: 100%;
    background: #ffd700;
    border-radius: 8px;
    z-index: 10;
  }
  .inimigo {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #e00909;
    border-radius: 8px;
    z-index: 4;
  }
   .brocheCobertor {
    position: absolute;
    width: 30px;
    height: 30px;
    background: #222;
    border-radius: 20px;
    z-index: 3;
    }
</style>
</head>
<body>
  <div class="arena" id="arena"></div>
<script>
// função de criação da entidade obstaculo!
const gerarObs = (pos) => {
    const o = document.createElement("div")
    o.className = "obst"
    o.style.left = pos.x + "px"
    o.style.top  = pos.y + "px"
    arena.appendChild(o)
    return o

}
// função de criação da arena, pega o elemento pelo ID do css e cola diretamente.
const arena = document.getElementById("arena")

const criarBloco = (pos) => {
    const b = document.createElement("div")
    b.className = "bloco"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
// processo de criação das entidades, onde cada elemento tem seu ID do css e posição baseado nos registros localizados abaixo desse bloco de funções.
};
const criarInimigo = (pos) => {
    const b = document.createElement("div")
    b.className = "inimigo"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
    
};
const criarGameOver = (pos) => {
    const b = document.createElement("div")
    b.className = "gameover"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarTelaInicial = (pos) => {
    const b = document.createElement("div")
    b.className = "TelaInicial"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBroche = (pos) => {
    const b = document.createElement("div")
    b.className = "broche"
    b.style.left = pos.x + "px"
    b.style.top  = pos.y + "px"
    arena.appendChild(b)
    return b
}
const criarBrocheCobertor = (pos) => {
    const b = document.createElement("div")
    b.className = "brocheCobertor"
    b.style.left = (pos.x- 5) + "px"
    b.style.top  = (pos.y - 5) + "px"
    arena.appendChild(b)
    return b
};
// bloco de registros onde marca as localizações das entidades geradas
// baseado em um plano cartesiano
const EstadoObst = {x: 100, y:300, height: 50, width: 50} 
const EstadoObst1 = { x: 100, y: 300, width: 50, height: 50 }
const EstadoObst2 = { x: 300, y: 100, width: 50, height: 50 }
const EstadoObst3 = { x: 500, y: 400, width: 50, height: 50 }
const EstadoObst4 = { x: 700, y: 200, width: 50, height: 50 }
const EstadoObst5 = { x: 900, y: 350, width: 50, height: 50 }
const EstadoObst6 = { x: 1100, y: 150, width: 50, height: 50 }
const EstadoObst7 = { x: 600, y: 550, width: 50, height: 50 }
const EstadoObst8 = { x: 1200, y: 500, width: 50, height: 50 }
const EstadoInicial = { x: 650, y: 300, height: 50, width: 50}
const ini2 = {x: 890, y: 500}
const gameoverInicial = {x: 0 , y: 0}
const inimigoInicial = {x:100, y: 20}
// bloco de criação ativa das entidades, pegando as funções e aplicando a posição como parametro.
const InimigoOficial = criarInimigo(inimigoInicial)
const bloco = criarBloco(EstadoInicial)
const estados = [EstadoObst1, EstadoObst2, EstadoObst3, EstadoObst4, EstadoObst5, EstadoObst6, EstadoObst7, EstadoObst8];
// map que gera todos os obstaculos presentes no array estados
const obstaculos = estados.map(estado => gerarObs(estado));
const inim2 = criarInimigo(ini2)
// função de movimentação, que calcula a posição baseado no addEventListener que virá a seguir!
const mover = (estado, tecla) => {
    const passo = 20
    const maxX = arena.clientWidth - 50
    const maxY = arena.clientHeight - 50
    // delimitação de constantes importantes para o movimento, e colisão com a arena!
    const novo = {
        x: tecla === 'ArrowRight' ? estado.x + passo : tecla === 'ArrowLeft'  ? estado.x - passo : estado.x,
        y: tecla === 'ArrowUp'    ? estado.y - passo : tecla === 'ArrowDown' ? estado.y + passo : estado.y,
        width: estado.width,
        height: estado.height
    };
    // registro que guarda a nova posição baseado no addEventlistener!
    const TestarColisão = estados.map((obs) => colisao(obs,novo))
    const filtro = TestarColisão.filter((obs) => obs === true)
    if(filtro.length > 0){
    // teste de colisão, usando um map para aplicar a função colisão que ainda vai ser definida,
    // usando um map para aplicar a função para todos, retornando arrays de true e false, o filtro
    // aliado com o .length ve se existe mais de zero colisões e caso afirmativo, retorna a posição
    // atual!
      return estado
    } 
    else {
      return {
        x: Math.min(Math.max(novo.x, 0), maxX),
        y: Math.min(Math.max(novo.y, 0), maxY),
        width: estado.width,
        height: estado.height
      };
    // bloco de função que testa colisão com a entidade obstáculo, como a função colisão foi feita após a movimentação
    // ela é chamada antes mesmo de ser definida, sendo só feita no final do código.
  }
}
  const broches = [
  { x: 50, y: 50 },
  { x: 150, y: 100 },
  { x: 250, y: 200 },
  { x: 100, y: 400 },
  { x: 300, y: 200 },
  { x: 400, y: 100 },
  { x: 600, y: 100 },
  { x: 800, y: 250 },
  { x: 1000, y: 300 },
  { x: 1250, y: 400 },
  { x: 200, y: 500 },
  { x: 350, y: 50 },
  { x: 750, y: 100 },
  { x: 950, y: 250 },
  { x: 1150, y: 300 }
]
// lista de posição dos broches que vão ser coletados!

const EntidadesBroches = broches.map((broche) => criarBroche(broche))
// map que cria cada broche como entidade baseado na função CriarBroche
// baseado em cada registro do array broches.
const MoverPersonagem = (estado,broches,EntBroches) => {
  document.addEventListener('keydown', (e) => {
  // Escutador de eventos que mapeia qual tecla esta sendo pressionada!
      const novo = mover(estado, e.key)
      // nova constante que aplica a função mover
      // ao estado atual, tendo como paramêtro a tecla pressionada
      renderPersonagem(novo)
      // aplica a função impura que mexe no DOM 
      // e pinta o bloco na nova posição no CSS
      if(ColetaDeBroches(broches,EntBroches) === true){
        MoverPersonagem(novo,broches.slice(1),EntBroches.slice(1))
      }
      // implementação recursiva que chama a função Coleta de Broches
      // caso o personagem toque o broche, aplica a função para a proxima
      // posição do array.
      else{
        MoverPersonagem(novo,broches,EntBroches)
        // caso não, mantém o broche atual!
      }
  }, {once:true}) // aplicação do AddEventListener que apaga o listener após o evento ser ativado
  // porém, por estar em um processo recursivo, o Listener retorna, isso impede que entre em um processo 
  // de recursão infinita e trave o navegador!
}
// função que movimenta o primeiro inimigo!
const moverInimigo = (player,inimigo) =>{
    const velocidade = 3
    const PlayerX = parseInt(player.style.left,10)
    const PlayerY = parseInt(player.style.top,10)
    const inimigoX = parseInt(inimigo.style.left,10)
    const inimigoY = parseInt(inimigo.style.top,10)
    // constantes importantes que consta a velocidade, e a
    // posição atual do player e do inimigo!
    const distanciax = PlayerX - inimigoX
    const distanciay = PlayerY - inimigoY
    const dist = Math.sqrt(distanciax**2 + distanciay**2) || 1
    // calculo do vetor (matemático) da distância entre o player e
    // o inimigo!
    if(dist < 50){
        return criarGameOver(gameoverInicial)
        // caso o vetor distância seja menor que 50, consta que o 
        // player foi pego e para a movimentação!
  } 
  else{
    return {
      x: inimigoX + (distanciax/dist) * velocidade,
      y: inimigoY + (distanciay/dist) * velocidade
    }
    // caso não, retorna uma nova coordenada 
    // onde a posição atual é somada a multiplicação 
    // do vetor normalizado com a velocidade do inimigo!
  }
}
const moverInimigo2 = (player,inimigo) =>{
    // essa função acaba sendo igual a função anterior
    // mas com velocidades diferentes, o que é importante
    // pois caso não os inimigos depois de um tempo acabam se 
    // fundindo!
    const velocidade = 5
    const blocoX = parseInt(player.style.left,10)
    const blocoY = parseInt(player.style.top,10)
    const inimigoX = parseInt(inimigo.style.left,10)
    const inimigoY = parseInt(inimigo.style.top,10)
    const distanciax = blocoX - inimigoX
    const distanciay = blocoY - inimigoY
    const dist = Math.sqrt(distanciax**2 + distanciay**2) || 1

    if(dist < 50){
        return criarGameOver(gameoverInicial)
  } 
  else{
    return {
      x: inimigoX + (distanciax/dist) * velocidade,
      y: inimigoY + (distanciay/dist) * velocidade
    }
  }
}
const render = (player,inimigo1,inimigo2) =>{
  const novo1 = moverInimigo(player,inimigo1)
  const novo2 = moverInimigo2(player,inimigo2)
  inimigo1.style.left = novo1.x + 'px'
  inimigo1.style.top = novo1.y + 'px'
  inimigo2.style.left = novo2.x + 'px'
  inimigo2.style.top = novo2.y + 'px'
  setTimeout(() => render(player,inimigo1, inimigo2), 32)
  // função impura que mexe no DOM para renderizar cada inimigo
  // pegando as coordenadas que saem de cada função e passam
  // para o CSS
}
const renderPersonagem = (estado) =>{
  bloco.style.left = estado.x + 'px'
  bloco.style.top = estado.y + 'px'
  // função que mexe no DOM e renderiza o player
}
const FunçãoAuxiliarColeta = (listaQualquer) =>{
  return listaQualquer.map((x) => x.style.display = 'none')
}
const FunçãoAuxiliarColeta2 = (x) =>{
  return x.style.display = 'block'
}
const FunçãoAuxiliarColeta3 = (x) =>{
  return x.style.display = 'none'
}
FunçãoAuxiliarColeta(EntidadesBroches)
const ColetaDeBroches = (estadosBroches, ElementosBroches) =>{
  if(estadosBroches.length === 0){
    const GameWon = criarGameOver(gameoverInicial)
    return
}
// como acaba sendo aplicado em um processo
// recursivo, precisa do caso base, que no caso
// é quando todos os broches são coletados
  const BlocoX = parseInt(bloco.style.left,10)
  const BlocoY = parseInt(bloco.style.top,10)
  const CoordenadasBrocheAtual = estadosBroches[0]
  const EntidadeBrocheAtual = ElementosBroches[0]
  FunçãoAuxiliarColeta2(EntidadeBrocheAtual)
  const filtro = ElementosBroches.filter((broche) => broche !== EntidadeBrocheAtual)
  FunçãoAuxiliarColeta(filtro)
  const distanciax = CoordenadasBrocheAtual.x - BlocoX
  const distanciay = CoordenadasBrocheAtual.y - BlocoY
  const dist = Math.sqrt(distanciax**2 + distanciay**2)
  if(dist < 50){
    FunçãoAuxiliarColeta3(EntidadeBrocheAtual)
    return true
  }
  else{
    return false
  }
}
const colisao = (obstaculo, player) => {
    if (player.x < obstaculo.x + obstaculo.width &&
    player.x + player.width > obstaculo.x &&
    player.y < obstaculo.y + obstaculo.height &&
    player.y + player.height > obstaculo.y){
        return true
    }
    else{
        return false
    }
// função de colisão do tipo AABB clássica!
}
// função de start do jogo, que ve o addEventListener para o Enter
// e inicia as duas funções de start do jogo, o loop e o moverInimigo
const FuncaoStart = () =>{
  const CriarTela = criarTelaInicial(gameoverInicial)
  document.addEventListener('keydown',(e) =>{
    if(e.key === 'Enter'){
        FunçãoAuxiliarColeta3(CriarTela)
        MoverPersonagem(EstadoInicial,broches,EntidadesBroches)
        render(bloco,InimigoOficial,inim2)
      }
    },{once: true})
}
FuncaoStart()

// VOU RECOMENTAR COM MAIS AFINCO QUANDO PUDER, tenho que terminar os comentarios ainda,
// mas agora eu to atrasado!!!!!

</script>
</body>
</html>
